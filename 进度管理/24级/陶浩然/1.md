# 9.12
## 代码(SCU_2025)运行结果：

使用的25赛季官方地图、读取开源的现场视频
![test](./image/9.12.png )

# 9.13
## 港科开源

* 梳理目录结构和文件内容
* 看投影位置计算（射线投影）的具体过程

# 9.14
## 相机成像原理

* 从世界坐标系到相机坐标系到照片上像素点的变化以及逆过程

## 港科开源

* 实际是图片像素转化到相机坐标系在到世界坐标系，再通过光心与实际坐标的连线与实际地图的plc交点即为世纪坐标

* 这种方式相对于传统的透视变化，具有更好的抗干扰性，在斜坡等非平地位置能够更好地解算出实际坐标位置

# 9.15~9.21
## 修改ABB比赛模型（用深度学习的方法去识别机械臂的转动角度无标定相机内外参等）的一些心得

* 并不是模型的参数越大训练出来的效果越好，我从原来的ResNet18改到了ResNet50后出现了明显的过拟合效应，应该是数据量较小但是模型层数与参数过大导致过拟合

* 加入了时间上的建模但是效果不明显且大大减慢了学习推理速度，浪费了算力

* 注意到了实际推理的视频具有连续性，在推理时加强了最终的平滑

* 机器学习很好的一个教程[李沐学AI](https://www.bilibili.com/video/BV1if4y147hS/?spm_id_from=333.337.search-card.all.click&vd_source=f5d67b6263fc5e307cc830f79e320af5)

# 9.22~9.24

ABB参赛

# 9.25~9.26

* 看线代，数学能力太差

# 9.27~10.08

## 计划与安排

- [ ]自瞄开源跑通（中南和同济）
- [ ]做港科开源中更改地图的点云图
- [ ]验证新地图下雷达的精度

## 具体完成情况
- [ ]中南自瞄已经测试完成
- [ ]同济自瞄已经能上车测试
- [ ]楼下大坑的基本建图已经完成

## 相关问题与解决方法

- [ ]中南：自瞄对横向移动的车急停会影响追踪（追踪不上向一个方向移动后快速反向）
    
    - [ ]~~解决方法(暂时想法)：使用IMM+机动检测+自适应Q~~
       
        1. ~~IMM：设定几个常见的模型，如CV（匀速）、CA（匀加速）、CTRV（匀速转弯），同时运行多个滤波器，根据观测误差（残差/似然），给出不同权重，最后融合计算~~

        2. ~~机动检测： IMM在预测时会花费几帧，机动检测能触发“保守策略”，即缩短预测步长、临时用零速模型、放大过程噪声（更相信测量），从而避免在危险几帧打偏~~

        3. ~~自适应Q：让IMM中每个滤波器都能“自适应”~~

           (已测试效果不好)



- [ ]同济：主要是标定和坐标系转化有问题
           
     1. 对于圆点标定：圆点标定时，要修改两个文件中的参数，一个是在configs-calibration.yaml中修改pattern_cols，pattern_rows，enter_distance_mm（横向圆点数、纵向圆点数，圆点间间距），其次是在calibration-capture.cpp中修改47～50中写死的Size值
     
     ```yaml
     // configs-calibration.yaml
     pattern_cols: 10
     pattern_rows: 7
     center_distance_mm: 40
     ```

     ```cpp
     // calibration-capture.cpp
     std::vector<cv::Point2f> centers_2d;
    auto success = cv::findCirclesGrid(img, cv::Size(10, 7), centers_2d);  // 默认是对称圆点图案
    cv::drawChessboardCorners(img_with_ypr, cv::Size(10, 7), centers_2d, success);  // 显示识别结果
    cv::resize(img_with_ypr, img_with_ypr, {}, 0.5, 0.5);  // 显示时缩小图片尺寸
    ```

    2. 对于手眼标定：在进行手眼标定时，应该保持标定板的位置不动，云台动，从而获取到在该标定板位置，不同位置云台的pitch和yaw

    3. 对于坐标系转化：如果上述问题均以解决，还是出现识别预测到的装甲板位置相差较大，则需考虑坐标系变化是否有问题，具体在configs-calibration.yaml中

    ```yaml
    // configs-calibration.yaml
    R_gimbal2imubody: [1, 0, 0, 0, 1, 0,  0, 0, 1]
    ```

# 10.09~10.12

## 关于港科雷达站调试tips

1. 建图：港科需要ply格式的地图，可以用solidworks建好图后导出为stl格式再用open3d转化为ply格式，也可直接安装mashlab后建图（具体转化代码和安装指令见下），一定要注意坐标轴的方向，如果坐标轴位置发生了改变需要修改以下两个文件中的参数

```python
# stl转化ply的python脚本

import open3d as o3d

# 读取 STL 文件
mesh = o3d.io.read_triangle_mesh("/home/thr/stl2ply/stl/test.STL")

# 转换为点云（如果需要）或直接保存网格
# 如果你的STL是网格，直接保存
o3d.io.write_triangle_mesh("/home/thr/stl2ply/ply/test.ply", mesh)

print("转换完成，已保存为 /home/thr/stl2ply/ply/test.ply")

```

```bash
// 安装meshlab
sudo apt update
sudo apt install meshlab

// 打开meshlab
meshlab
```

```txt
# transform-kepoint_6.txt
# 这个文件中的三个坐标排列顺序为(x,y,z)其值为世界坐标值（也是ply中的坐标值），单位为m

-4.430 0.803 3.969
-3.857   1.748  -2.907 
-3.55    0.735 -10.334 
-0.344   2.598   0.35
2.299   0.273 -10.975
4.21    0.403   3.531
```

```python
# transform-solidwork2uwb.py
# 修改pos_x和pos_y的计算方式（如果坐标系发生了改变）
def solidwork2uwb(pos_3d: List[float], faction: FACTION = FACTION.RED) -> List[float]:
    x, y, z = pos_3d
    if (
        faction == FACTION.RED
        or faction == FACTION.UNKONWN
    ):
        pos_x = (-z + 14.0)
        pos_y = (-x + 7.5)
    elif faction == FACTION.BLUE:
        x, y, z = pos_3d
        pos_x = 28.0 - (-z + 14.0)
        pos_y = 15.0 - (-x + 7.5)
    return pos_x, pos_y
```

# 联系方式

 QQ:2523774517
 
 email: 2523774515@qq.com
 
 WeChat:YikT_2631
 
 phone:19136311737
